<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wennnnç·šä¸Šåœ–ç‰‡ç·¨è¼¯å™¨ (Canvas)</title>
    <style>
        /* æ•´é«”é é¢æ¨£å¼ */
        :root {
            --primary-color: #007bff;
            --light-gray: #f8f9fa;
            --dark-gray: #343a40;
            --border-color: #dee2e6;
            --shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.1);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: var(--light-gray);
            margin: 0;
            padding: 20px;
            color: var(--dark-gray);
        }

        h1 {
            color: var(--dark-gray);
            margin-bottom: 25px;
        }

        /* å·¥å…·åˆ—æ¨£å¼ */
        #toolbar {
            width: 95%;
            max-width: 1200px;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            padding: 1rem 1.5rem;
            border-radius: 1rem;
            box-shadow: var(--shadow);
            margin-bottom: 2rem;
            display: flex;
            gap: 1.5rem;
            align-items: center;
            flex-wrap: wrap;
            border: 1px solid rgba(255, 255, 255, 0.18);
        }

        .tool-group {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.5rem;
            border-right: 1px solid var(--border-color);
        }
        .tool-group:last-child {
            border-right: none;
        }

        #toolbar label {
            font-weight: 500;
            font-size: 0.9rem;
            cursor: pointer;
        }

        /* æŒ‰éˆ•æ¨£å¼ */
        #toolbar button {
            padding: 0.5rem 1rem;
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            cursor: pointer;
            background-color: #fff;
            transition: all 0.2s ease;
            font-size: 0.9rem;
        }

        #toolbar button:hover {
            background-color: #e9ecef;
            border-color: #adb5bd;
            transform: translateY(-2px);
        }
        
        #toolbar button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        #toolbar button.active {
            background-color: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
            box-shadow: 0 2px 8px rgba(0, 123, 255, 0.4);
        }

        /* è¼¸å…¥æ§åˆ¶é …æ¨£å¼ */
        input[type="checkbox"] { cursor: pointer; }
        input[type="color"] {
            width: 38px; height: 38px; border: none; border-radius: 8px; cursor: pointer; padding: 0;
        }
        input[type="range"] { cursor: pointer; }
        input[type="number"] { width: 60px; padding: 0.5rem; border: 1px solid var(--border-color); border-radius: 0.5rem; }
        input[type="text"] { width: 180px; padding: 0.5rem; border: 1px solid var(--border-color); border-radius: 0.5rem; }
        input[type="file"] { border: 1px solid var(--border-color); padding: 0.5rem; border-radius: 0.5rem; font-size: 0.85rem; }
        
        /* ç•«å¸ƒå®¹å™¨ */
        #canvas-container {
            border: 1px solid var(--border-color);
            padding: 0.5rem;
            border-radius: 1rem;
            background-color: #ffffff;
            box-shadow: var(--shadow);
            position: relative;
        }
        
        canvas { display: block; max-width: 100%; height: auto; }

        /* ç•«å¸ƒä¸Šæ–‡å­—è¼¸å…¥ */
        .on-canvas-input {
            position: absolute; background: rgba(255, 255, 255, 0.95); border: 1px dashed var(--primary-color);
            padding: 2px; margin: 0; outline: none; z-index: 100; resize: none; overflow: hidden; white-space: pre;
        }
    </style>
</head>
<body>

    <h1>âœ¨ Wennnnç·šä¸Šåœ–ç‰‡ç·¨è¼¯å™¨ âœ¨</h1>

    <div id="toolbar">
        <div class="tool-group">
            <input type="file" id="uploader" accept="image/*">
        </div>

        <div class="tool-group">
            <label>å·¥å…·:</label>
            <button class="tool-btn active" data-tool="select" title="ç§»å‹•/é¸å–/ç¸®æ”¾">ğŸ–ï¸</button>
            <button class="tool-btn" data-tool="rect" title="çŸ©å½¢">â–­</button>
            <button class="tool-btn" data-tool="line" title="ç·šæ¢">âˆ•</button>
            <button class="tool-btn" data-tool="text" title="æ–‡å­—">T</button>
        </div>

        <div class="tool-group">
            <input type="checkbox" id="continuous-drawing-checkbox" title="é€£çºŒç¹ªè£½ç›¸åŒåœ–å½¢">
            <label for="continuous-drawing-checkbox">é€£çºŒç¹ªè£½</label>
        </div>

        <div class="tool-group">
            <label for="color-picker">é¡è‰²:</label>
            <input type="color" id="color-picker" value="#E74C3C">
            <label for="opacity-slider">é€æ˜åº¦:</label>
            <input type="range" id="opacity-slider" min="0" max="1" step="0.01" value="1">
            <span id="opacity-value">1.0</span>
        </div>

        <div class="tool-group">
            <label for="line-width">ç·šæ¢:</label>
            <input type="range" id="line-width" min="1" max="100" value="5">
            <span id="line-width-value">5</span>
        </div>
        
        <div class="tool-group">
            <label for="font-size">æ–‡å­—:</label>
            <input type="range" id="font-size" min="10" max="200" value="30">
            <input type="number" id="font-size-input" min="10" max="200" value="30">
        </div>
        
        <div class="tool-group">
            <label>æ­·å²:</label>
            <button id="undo-btn" title="å¾©åŸ (Ctrl+Z)">â†©ï¸</button>
            <button id="redo-btn" title="é‡åš (Ctrl+Y)">â†ªï¸</button>
        </div>

        <div class="tool-group">
            <button id="delete-btn" title="åˆªé™¤é¸å–">ğŸ—‘ï¸</button>
            <input type="text" id="download-name-input" title="ä¸‹è¼‰æª”å" value="edited-image">
            <button id="download-btn" style="background-color: #28a745; color: white;">ä¸‹è¼‰åœ–ç‰‡</button>
        </div>
    </div>

    <div id="canvas-container">
        <canvas id="canvas" width="800" height="600"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // --- DOM å…ƒç´  ---
        const uploader = document.getElementById('uploader');
        const colorPicker = document.getElementById('color-picker');
        const opacitySlider = document.getElementById('opacity-slider'); // NEW
        const opacityValue = document.getElementById('opacity-value');   // NEW
        const lineWidthInput = document.getElementById('line-width');
        const lineWidthValue = document.getElementById('line-width-value');
        const fontSizeInput = document.getElementById('font-size');
        const fontSizeNumInput = document.getElementById('font-size-input');
        const downloadBtn = document.getElementById('download-btn');
        const downloadNameInput = document.getElementById('download-name-input');
        const deleteBtn = document.getElementById('delete-btn');
        const toolBtns = document.querySelectorAll('.tool-btn');
        const undoBtn = document.getElementById('undo-btn');
        const redoBtn = document.getElementById('redo-btn');
        const continuousDrawingCheckbox = document.getElementById('continuous-drawing-checkbox');
        
        // --- æ‡‰ç”¨ç¨‹å¼ç‹€æ…‹è®Šæ•¸ ---
        let objects = [];
        let backgroundImage = null;
        let originalFilename = null; 
        let currentTool = 'select';
        let isDrawing = false, isDragging = false, isResizing = false;
        let selectedObject = null;
        let startX, startY, dragOffsetX, dragOffsetY;
        let tempInput = null;
        let resizingHandle = null;
        const handleSize = 8;
        let originalObjectProps = {};

        // --- History (Undo/Redo) ---
        let history = [];
        let historyIndex = -1;

        // --- æ ¸å¿ƒå‡½å¼ ---
        function redrawCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = "#ffffff";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            if (backgroundImage) ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);
            objects.forEach(drawObject);
            if (selectedObject) drawSelection(selectedObject);
        }

        function drawObject(obj) {
            const rgbaColor = hexToRgba(obj.color, obj.opacity); // USE RGBA
            ctx.strokeStyle = rgbaColor;
            ctx.fillStyle = rgbaColor;
            if (obj.type === 'rect' || obj.type === 'line') {
                ctx.lineWidth = obj.lineWidth;
                ctx.beginPath();
                if (obj.type === 'rect') ctx.strokeRect(obj.x, obj.y, obj.width, obj.height);
                else { ctx.moveTo(obj.x, obj.y); ctx.lineTo(obj.x + obj.width, obj.y + obj.height); }
                ctx.stroke();
            } else if (obj.type === 'text') {
                ctx.font = `${obj.fontSize}px Arial`;
                ctx.textBaseline = 'top';
                obj.text.split('\n').forEach((line, i) => ctx.fillText(line, obj.x, obj.y + (i * obj.fontSize * 1.1)));
            }
        }

        function drawSelection(obj) {
            ctx.strokeStyle = 'rgba(0, 123, 255, 0.8)';
            ctx.lineWidth = 2;
            const bounds = getObjectBounds(obj);
            if (obj.type !== 'line') {
                ctx.setLineDash([6, 4]);
                ctx.strokeRect(bounds.x, bounds.y, bounds.width, bounds.height);
                ctx.setLineDash([]);
            }
            drawHandles(obj);
        }

        // --- äº‹ä»¶ç›£è½å™¨è¨­å®š ---
        uploader.addEventListener('change', (e) => {
            const file = e.target.files[0]; if (!file) return;
            originalFilename = file.name.split('.').slice(0, -1).join('.');
            downloadNameInput.value = `${originalFilename}_ç¹ªè£½ç‰ˆ`;
            const reader = new FileReader();
            reader.onload = (event) => {
                backgroundImage = new Image();
                backgroundImage.onload = () => { canvas.width = backgroundImage.width; canvas.height = backgroundImage.height; redrawCanvas(); saveState(); };
                backgroundImage.src = event.target.result;
            };
            reader.readAsDataURL(file);
        });

        toolBtns.forEach(btn => btn.addEventListener('click', () => {
            toolBtns.forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            currentTool = btn.dataset.tool;
            canvas.style.cursor = 'default';
            selectedObject = null;
            if(tempInput) tempInput.blur();
            redrawCanvas();
        }));
        
        const syncFontSize = (value) => {
            fontSizeInput.value = value; fontSizeNumInput.value = value;
            if (selectedObject && selectedObject.type === 'text') { selectedObject.fontSize = value; redrawCanvas(); }
        };
        fontSizeInput.addEventListener('input', (e) => syncFontSize(e.target.value));
        fontSizeNumInput.addEventListener('input', (e) => syncFontSize(e.target.value));
        fontSizeInput.addEventListener('change', saveState);
        fontSizeNumInput.addEventListener('change', saveState);

        lineWidthInput.addEventListener('input', (e) => {
            lineWidthValue.textContent = e.target.value;
            if (selectedObject && (selectedObject.type === 'rect' || selectedObject.type === 'line')) {
                selectedObject.lineWidth = e.target.value; redrawCanvas();
            }
        });
        lineWidthInput.addEventListener('change', saveState);

        colorPicker.addEventListener('change', (e) => {
            if (selectedObject) {
                selectedObject.color = e.target.value; redrawCanvas(); saveState();
            }
        });
        
        // NEW: Opacity Slider Listener
        opacitySlider.addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            opacityValue.textContent = value.toFixed(2);
            if (selectedObject) {
                selectedObject.opacity = value;
                redrawCanvas();
            }
        });
        opacitySlider.addEventListener('change', saveState);

        canvas.addEventListener('mousedown', (e) => {
            if (tempInput) { tempInput.blur(); return; }
            const { x, y } = getMousePos(e); startX = x; startY = y;
            resizingHandle = getHandleAtPosition(x, y);
            if (currentTool === 'select' && resizingHandle) {
                isResizing = true;
                originalObjectProps = JSON.parse(JSON.stringify(selectedObject));
            } else if (currentTool === 'select') {
                selectedObject = getObjectAtPosition(x, y);
                if (selectedObject) {
                    isDragging = true; dragOffsetX = x - selectedObject.x; dragOffsetY = y - selectedObject.y;
                    updateToolbarForSelection(selectedObject);
                }
            } else if (currentTool === 'text') {
                createOnCanvasInput(x, y);
            } else {
                isDrawing = true;
            }
            redrawCanvas();
        });

        canvas.addEventListener('mousemove', (e) => {
            const { x, y } = getMousePos(e);
            if (isResizing) { resizeObject(x, y); redrawCanvas(); return; }
            if (isDragging) { selectedObject.x = x - dragOffsetX; selectedObject.y = y - dragOffsetY; redrawCanvas(); return; }
            if (isDrawing) {
                redrawCanvas();
                const previewColor = hexToRgba(colorPicker.value, 0.7); // Preview with some transparency
                ctx.strokeStyle = previewColor;
                ctx.lineWidth = lineWidthInput.value;
                if (currentTool === 'rect') ctx.strokeRect(startX, startY, x - startX, y - startY);
                else if (currentTool === 'line') { ctx.beginPath(); ctx.moveTo(startX, startY); ctx.lineTo(x, y); ctx.stroke(); }
                return;
            }
            updateCursor(e);
        });

        canvas.addEventListener('mouseup', (e) => {
            let stateChanged = false;
            if (isDrawing) {
                const { x, y } = getMousePos(e);
                let newObject = { type: currentTool, x: Math.min(startX, x), y: Math.min(startY, y), width: Math.abs(x - startX), height: Math.abs(y - startY), color: colorPicker.value, opacity: parseFloat(opacitySlider.value), lineWidth: lineWidthInput.value, fontSize: fontSizeInput.value };
                if (currentTool === 'line') newObject = { ...newObject, x: startX, y: startY, width: x - startX, height: y - startY };
                if ((newObject.width > 5 || newObject.height > 5 || currentTool === 'line') && (newObject.width !== 0 || newObject.height !== 0)) {
                    objects.push(newObject);
                    stateChanged = true;
                    if (!continuousDrawingCheckbox.checked) {
                        document.querySelector('.tool-btn[data-tool="select"]').click();
                    }
                }
            }
            if (isDragging || isResizing) stateChanged = true;
            if (stateChanged) saveState();
            isDrawing = isDragging = isResizing = false; resizingHandle = null;
            redrawCanvas();
        });

        canvas.addEventListener('dblclick', (e) => {
            if (currentTool !== 'select') return;
            const { x, y } = getMousePos(e);
            const clickedObject = getObjectAtPosition(x, y);
            if (clickedObject && clickedObject.type === 'text') {
                selectedObject = null;
                objects = objects.filter(obj => obj !== clickedObject);
                redrawCanvas();
                createOnCanvasInput(clickedObject.x, clickedObject.y, clickedObject.text, clickedObject.color, clickedObject.fontSize, clickedObject.opacity);
            }
        });

        downloadBtn.addEventListener('click', () => {
            selectedObject = null; 
            redrawCanvas();
            const link = document.createElement('a');
            let downloadName = downloadNameInput.value.trim() || (originalFilename ? `${originalFilename}_ç¹ªè£½ç‰ˆ` : 'edited-image');
            if (!downloadName.toLowerCase().endsWith('.png')) downloadName += '.png';
            link.download = downloadName;
            link.href = canvas.toDataURL('image/png');
            link.click();
        });
        
        deleteBtn.addEventListener('click', () => {
            if (selectedObject) {
                objects = objects.filter(obj => obj !== selectedObject);
                selectedObject = null;
                redrawCanvas();
                saveState();
            }
        });
        
        // --- History Handlers ---
        undoBtn.addEventListener('click', undo);
        redoBtn.addEventListener('click', redo);
        window.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.key === 'z') { e.preventDefault(); undo(); }
            if (e.ctrlKey && e.key === 'y') { e.preventDefault(); redo(); }
        });

        // --- è¼”åŠ©å‡½å¼ ---
        function createOnCanvasInput(x, y, text = '', color, fontSize, opacity) {
            if (tempInput) tempInput.blur();
            const rect = canvas.getBoundingClientRect(); const scaleY = rect.height / canvas.height; const scaleX = rect.width / canvas.width;
            color = color || colorPicker.value;
            fontSize = fontSize || fontSizeInput.value;
            opacity = opacity !== undefined ? opacity : parseFloat(opacitySlider.value);
            
            tempInput = document.createElement('textarea'); tempInput.value = text; tempInput.className = 'on-canvas-input';
            document.body.appendChild(tempInput);
            Object.assign(tempInput.style, {
                position: 'absolute', left: `${rect.left + window.scrollX + (x * scaleX)}px`, top: `${rect.top + window.scrollY + (y * scaleY)}px`,
                color: color, fontSize: `${fontSize * scaleY}px`, fontFamily: 'Arial', lineHeight: '1.1'
            });
            setTimeout(() => tempInput.focus(), 0);
            const autoResize = () => { if (!tempInput) return; tempInput.style.height = 'auto'; tempInput.style.width = 'auto'; tempInput.style.height = tempInput.scrollHeight + 'px'; tempInput.style.width = tempInput.scrollWidth + 'px'; };
            tempInput.addEventListener('input', autoResize); setTimeout(autoResize, 0);
            const finalize = () => {
                if (!tempInput) return;
                const newText = tempInput.value; 
                if (newText) {
                    objects.push({ type: 'text', text: newText, x, y, color: color, opacity: opacity, fontSize: fontSize });
                }
                document.body.removeChild(tempInput); 
                tempInput = null; 
                if (!continuousDrawingCheckbox.checked) {
                    document.querySelector('.tool-btn[data-tool="select"]').click();
                } else {
                    redrawCanvas();
                }
                saveState();
            };
            tempInput.addEventListener('blur', finalize);
            tempInput.addEventListener('keydown', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); tempInput.blur(); } });
        }
        
        function hexToRgba(hex, alpha = 1) {
            let r = 0, g = 0, b = 0;
            if (hex.length == 4) {
                r = parseInt(hex[1] + hex[1], 16); g = parseInt(hex[2] + hex[2], 16); b = parseInt(hex[3] + hex[3], 16);
            } else if (hex.length == 7) {
                r = parseInt(hex.substring(1, 3), 16); g = parseInt(hex.substring(3, 5), 16); b = parseInt(hex.substring(5, 7), 16);
            }
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        function getMousePos(evt) {
            const rect = canvas.getBoundingClientRect(); const scaleX = canvas.width / rect.width; const scaleY = canvas.height / rect.height;
            return { x: (evt.clientX - rect.left) * scaleX, y: (evt.clientY - rect.top) * scaleY };
        }

        function updateToolbarForSelection(obj) {
            colorPicker.value = obj.color;
            opacitySlider.value = obj.opacity;
            opacityValue.textContent = obj.opacity.toFixed(2);
            if (obj.type === 'text') {
                syncFontSize(obj.fontSize);
            } else {
                lineWidthInput.value = obj.lineWidth;
                lineWidthValue.textContent = obj.lineWidth;
            }
        }
        
        function updateCursor(e) {
            if (currentTool !== 'select') { canvas.style.cursor = 'crosshair'; return; }
            const { x, y } = getMousePos(e);
            const handle = getHandleAtPosition(x, y);
            if (handle) {
                if (selectedObject && selectedObject.type === 'line') { canvas.style.cursor = 'pointer'; } 
                else {
                    if (handle.includes('n') || handle.includes('s')) canvas.style.cursor = 'ns-resize';
                    else if (handle.includes('w') || handle.includes('e')) canvas.style.cursor = 'ew-resize';
                    else if ((handle.startsWith('n') && handle.endsWith('w')) || (handle.startsWith('s') && handle.endsWith('e'))) canvas.style.cursor = 'nwse-resize';
                    else canvas.style.cursor = 'nesw-resize';
                }
            } else if (getObjectAtPosition(x, y)) {
                canvas.style.cursor = 'move';
            } else {
                canvas.style.cursor = 'default';
            }
        }

        // --- Scaling and Selection Functions ---
        function getObjectBounds(obj) {
            if (obj.type === 'text') {
                ctx.font = `${obj.fontSize}px Arial`;
                const lines = obj.text.split('\n'); let textWidth = 0;
                lines.forEach(line => { const w = ctx.measureText(line).width; if (w > textWidth) textWidth = w; });
                const textHeight = obj.fontSize * lines.length * 1.1;
                return { x: obj.x, y: obj.y, width: textWidth, height: textHeight };
            } else if (obj.type === 'line') {
                return { x: Math.min(obj.x, obj.x + obj.width), y: Math.min(obj.y, obj.y + obj.height), width: Math.abs(obj.width), height: Math.abs(obj.height) };
            }
            return { x: obj.x, y: obj.y, width: obj.width, height: obj.height };
        }
        function getHandles(obj) {
            if (obj.type === 'line') {
                return { 'start': { x: obj.x, y: obj.y }, 'end': { x: obj.x + obj.width, y: obj.y + obj.height } };
            }
            const b = getObjectBounds(obj);
            return { 'nw':{x:b.x,y:b.y}, 'n':{x:b.x+b.width/2,y:b.y}, 'ne':{x:b.x+b.width,y:b.y}, 'w':{x:b.x,y:b.y+b.height/2}, 'e':{x:b.x+b.width,y:b.y+b.height/2}, 'sw':{x:b.x,y:b.y+b.height}, 's':{x:b.x+b.width/2,y:b.y+b.height}, 'se':{x:b.x+b.width,y:b.y+b.height} };
        }
        function drawHandles(obj) {
            const handles = getHandles(obj);
            ctx.fillStyle = '#fff'; 
            ctx.strokeStyle = '#007bff';
            ctx.lineWidth = 1;
            for (const key in handles) {
                const h = handles[key]; ctx.beginPath();
                ctx.rect(h.x - handleSize / 2, h.y - handleSize / 2, handleSize, handleSize);
                ctx.fill(); ctx.stroke();
            }
        }
        function getHandleAtPosition(x, y) {
            if (!selectedObject) return null;
            const handles = getHandles(selectedObject);
            for (const key in handles) {
                const h = handles[key];
                if (x >= h.x - handleSize && x <= h.x + handleSize && y >= h.y - handleSize && y <= h.y + handleSize) return key;
            }
            return null;
        }
        function resizeObject(mouseX, mouseY) {
            const obj = selectedObject, orig = originalObjectProps;
            if (obj.type === 'line') {
                const origEndX = orig.x + orig.width, origEndY = orig.y + orig.height;
                if (resizingHandle === 'start') {
                    obj.x = mouseX; obj.y = mouseY; obj.width = origEndX - mouseX; obj.height = origEndY - mouseY;
                } else { obj.width = mouseX - obj.x; obj.height = mouseY - obj.y; }
                return; 
            }
            let { x, y, width, height } = getObjectBounds(orig);
            if (resizingHandle.includes('e')) width = mouseX - x;
            if (resizingHandle.includes('w')) { width += x - mouseX; x = mouseX; }
            if (resizingHandle.includes('s')) height = mouseY - y;
            if (resizingHandle.includes('n')) { height += y - mouseY; y = mouseY; }
            if (obj.type === 'text') {
                const originalWidth = getObjectBounds(orig).width || 1;
                const scale = Math.abs(width) / originalWidth;
                obj.fontSize = Math.max(5, orig.fontSize * scale);
                obj.x = x; obj.y = y;
            } else { obj.x = x; obj.y = y; obj.width = width; obj.height = height; }
        }
        function getObjectAtPosition(x, y) {
            for (let i = objects.length - 1; i >= 0; i--) {
                const obj = objects[i]; const bounds = getObjectBounds(obj);
                if (obj.type === 'line') {
                    const dist = distToSegment({x, y}, {x: obj.x, y: obj.y}, {x: obj.x + obj.width, y: obj.y + obj.height});
                    if (dist < Math.max(10, obj.lineWidth / 2)) return obj;
                } else {
                    if (x >= bounds.x && x <= bounds.x + bounds.width && y >= bounds.y && y <= bounds.y + bounds.height) return obj;
                }
            }
            return null;
        }

        function distToSegment(p, v, w) {
            const l2 = (v.x - w.x)**2 + (v.y - w.y)**2;
            if (l2 == 0) return Math.sqrt((p.x - v.x)**2 + (p.y - v.y)**2);
            let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
            t = Math.max(0, Math.min(1, t));
            return Math.sqrt((p.x - (v.x + t * (w.x - v.x)))**2 + (p.y - (v.y + t * (w.y - v.y)))**2);
        }

        // --- History Functions ---
        function saveState() {
            history.length = historyIndex + 1;
            history.push(JSON.parse(JSON.stringify(objects)));
            historyIndex++;
            updateHistoryButtons();
        }
        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                objects = JSON.parse(JSON.stringify(history[historyIndex]));
                selectedObject = null;
                redrawCanvas();
                updateHistoryButtons();
            }
        }
        function redo() {
            if (historyIndex < history.length - 1) {
                historyIndex++;
                objects = JSON.parse(JSON.stringify(history[historyIndex]));
                selectedObject = null;
                redrawCanvas();
                updateHistoryButtons();
            }
        }
        function updateHistoryButtons() {
            undoBtn.disabled = historyIndex <= 0;
            redoBtn.disabled = historyIndex >= history.length - 1;
        }
        
        // Initial state
        saveState();
        redrawCanvas();
    </script>
</body>
</html>

